#!/usr/bin/env node
'use strict';
const program = require('commander');
const path = require('path');
const fs = require('fs-extra');
const pathExists = require('path-exists').sync;
const delib = require('./../index');
const config = require('./../src/config/config');
const optionActions = require('./../src/cli/optionactions');
const help = require('./../src/cli/help');
const info = require('./../src/cli/info');

program
  .version('3.6.0')
  .usage('[options][command][options]');

/** Initializes DeLib by creating a configuration file and the contracts folder. */
program
  .command('init')
  .description('Create the Delib project structure: addresses/, built/, contracts/, delib.js')
  .action(() => {
    const configPath = path.join(process.cwd(), 'delib.js');
    const contractsFolderPath = path.join(process.cwd(), 'contracts');
    const builtFolderPath = path.join(process.cwd(), 'built');
    const addressFolderPath = path.join(process.cwd(), 'addresses');

    let status = false;

    if (!pathExists(configPath)) {
      const defaultConfig = fs.readFileSync(path.join(__dirname, '/../src/config/default.js'));
      fs.writeFileSync(configPath, defaultConfig);
      console.log('Created configuration file: delib.js');
      status = true;
    }

    if (!pathExists(contractsFolderPath)) {
      fs.mkdirSync(contractsFolderPath);
      console.log('Created contracts folder: contracts/');
      status = true;
    }

    if (!pathExists(builtFolderPath)) {
      fs.mkdirSync(builtFolderPath);
      console.log('Created built contracts folder: built/');
      status = true;
    }

    if (!pathExists(addressFolderPath)) {
      fs.mkdirSync(addressFolderPath);
      console.log('Created contract addresses folder: addresses/');
      status = true;
    }

    if (status === false) {
      console.log('Already created project');
    }
  });

/** Build a Solidity contract from paths in delib configuration file. Default is './contracts/' */
program
  .command('build <file>')
  .alias('bu')
  .description('Build a Solidity contract')
  .option('-h --rpchost <value>', 'RPC host')
  .option('-r --rpcport <port>', 'RPC port')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .option('-o --contract <path>', 'Relative path to contracts folder')
  .option('-b --built <path>', 'Relative path to built contracts folder')
  .action((file, options) => {
    options = optionActions(options, 'none');

    const contractPath = path.join(config.projectRoot, delib.eth.contracts.paths.contract, file + '.sol');
    if (!pathExists(contractPath)) {
      console.log('');
      console.log('  \'' + file + '\' is not a valid contract at:', contractPath);
      console.log('');
      return;
    }

    console.log('Building:', contractPath);
    delib.eth.build(file)
      .then((contracts) => {
        // console.log('Built path:', path.join(config.projectRoot, delib.eth.contracts.paths.built));
        console.log('Contracts built:', contracts.join(', '));
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.log(err);
        delib.eth.closeIPC();
      });
  });

/** Deploy a Solidity contract from paths in delib configuration file. Default is './contracts/'. */
program
  .command('deploy <contractName> [args...]')
  .alias('de')
  .description('Deploy a built contract')
  .option('-i --account <index>', 'Account to use for transaction. Takes the account index')
  .option('-f --from <address>', 'From transaction option. Replaces --account')
  .option('-t --to <address>', 'To transaction option')
  .option('-v --value <ether>', 'Value transaction option in Ether. Converts the value to wei')
  .option('-g --gas <number>', 'Gas transaction option. Estimated if not given or set to 0')
  .option('-p --gasprice <number>', 'Gas price transaction option')
  .option('-n --nonce <number>', 'Nonce transaction option')
  .option('-m --maxgas <number>', 'Max gas allowed when estimating')
  .option('-h --rpchost <value>', 'RPC host')
  .option('-r --rpcport <port>', 'RPC port')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .option('-b --built <path>', 'Relative path to built contracts folder')
  .option('-a --address <path>', 'Relative path to addresses folder')
  .action((contractName, args, options) => {
    options = optionActions(options);

    // Check if built contract exists
    const builtPath = path.join(config.projectRoot, delib.eth.contracts.paths.built, contractName + '.sol.js');
    if (!pathExists(builtPath)) {
      console.log('');
      console.log('  \'' + contractName + '\' is not a valid built contract at:', builtPath);
      console.log('');
      return;
    }

    console.log('Deploying:', builtPath);
    delib.eth.deploy(contractName, args, options)
      .then(instance => {
        // console.log('Address path:', path.join(config.projectRoot, delib.eth.contracts.paths.address));
        console.log('Contract address:', instance.address);
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.error(err);
        delib.eth.closeIPC();
      });
  });

/** Executes a deployed contract with specified method and provided arguments. */
program
  .command('exec <contractName> <method> [args...]')
  .description('Execute a contract method')
  .alias('ex')
  .option('-i --account <index>', 'Account to use for transaction. Takes the account index')
  .option('-f --from <address>', 'From transaction option. Replaces --account')
  .option('-t --to <address>', 'To transaction option.')
  .option('-v --value <ether>', 'Value transaction option in Ether. Converts the value to wei')
  .option('-g --gas <number>', 'Gas transaction option')
  .option('-p --gasprice <number>', 'Gas price transaction option')
  .option('-n --nonce <number>', 'Nonce transaction option')
  .option('-m --maxgas <number>', 'Max gas allowed when estimating')
  .option('-h --rpchost <value>', 'RPC host')
  .option('-r --rpcport <port>', 'RPC port')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .option('-b --built <path>', 'Relative path to built contracts folder')
  .option('-a --address <path>', 'Relative path to addresses folder')
  .action((contractName, method, args, options) => {
    options = optionActions(options);

    // Check if built contract exists
    const builtPath = path.join(config.projectRoot, delib.eth.contracts.paths.built, contractName + '.sol.js');
    if (!pathExists(builtPath)) {
      console.log('');
      console.log('  \'' + contractName + '\' is not a valid built contract at:', builtPath);
      console.log('');
      return;
    }

    // Check if contract method exists. The returned contract instance has custom methods. The actual methods are __methodName
    const contractInstance = delib.eth.exec(contractName);

    const abis = contractInstance.abi;

    function checkMethod(method, abis) {
      for (let i = 0; i < abis.length; i++) {
        if (abis[i].name === method && abis[i].type === 'function') {
          return true;
        }
      }
      return false;
    }

    if (!checkMethod(method, abis)) {
      console.log('');
      console.log('  \'' + method + '\' is not a valid', contractName, 'method');
      console.log('');
      return;
    }

    args.push(options);
    contractInstance[method].apply(this, args)
      .then(txRes => {
        console.log('Response:', txRes);
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.error(err);
        delib.eth.closeIPC();
      });
  });

/** Show the logs of a contract event. */
program
  .command('events <contractName> <eventName> [blocksBack]')
  .alias('ev')
  .description('Get the logs of an event')
  .option('-h --rpchost <value>', 'RPC host')
  .option('-r --rpcport <port>', 'RPC port')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .option('-b --built <path>', 'Relative path to built contracts folder')
  .option('-a --address <path>', 'Relative path to addresses folder')
  .action((contractName, eventName, blocksBack, options) => {
    optionActions(options);

    const builtPath = path.join(config.projectRoot, delib.eth.contracts.paths.built, contractName + '.sol.js');
    if (!pathExists(builtPath)) {
      console.log('');
      console.log('  \'' + contractName + '\' is not a valid built contract at:', builtPath);
      console.log('');
      return;
    }

    // Check if event exists
    const contract = delib.eth.builtContract(contractName);
    const contractAddress = delib.eth.contracts.addresses.get(contractName);
    const contractInstance = contract.at(contractAddress);
    const abis = contractInstance.abi;

    function checkEvent(eventName, abis) {
      if (eventName === 'allEvents') return true;
      for (let i = 0; i < abis.length; i++) {
        if (abis[i].name === eventName && abis[i].type === 'event') {
          return true;
        }
      }
      return false;
    }

    if (!checkEvent(eventName, abis)) {
      console.log('');
      console.log('  \'' + eventName + '\' is not a valid', contractName, 'event');
      console.log('');
      return;
    }

    delib.eth.eventsAt(contractName, contractAddress, eventName, blocksBack)
      .then(logs => {
        console.log('Event logs:');
        logs = logs.map(log => { return log.args; });
        console.log(logs);
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.error(err);
        delib.eth.closeIPC();
      });
  });

/** List a contracts info */
program
  .command('info <contractName>')
  .description('Show contract info (methods, events, address)')
  .option('-b --built <path>', 'Relative path to built contracts folder')
  .option('-a --address <path>', 'Relative path to addresses folder')
  .action(info);

/** Set the address of a contract to call methods on */
program
  .command('set <contractName> <contractAddress>')
  .option('-a --address <path>', 'Relative path to addresses folder')
  .description('Set the address of a contract to use')
  .action((contractName, contractAddress, options) => {
    optionActions(options);
    delib.eth.contracts.addresses.set(contractName, contractAddress);
  });

/** Get the balance of a particular Ethereum account based on account index. */
program
  .command('balance <index> [denomination]')
  .description('Get the balance of an Ethereum account by its index')
  .option('-h --rpchost <value>', 'RPC host')
  .option('-r --rpcport <port>', 'RPC port')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .action((index, denomination, options) => {
    optionActions(options);
    if (delib.eth.connectionType !== 'ipc') {
      const balance = delib.eth.getBalance(index, denomination);
      console.log(balance);
    } else {
      delib.eth.getBalance(index, denomination)
        .then(balance => {
          console.log(balance);
          delib.eth.closeIPC();
        })
        .catch(err => {
          console.error(err);
          delib.eth.closeIPC();
        });
    }
  });

/** Create a new Ethereum account. */
program
  .command('create <password>')
  .description('Create an Ethereum account')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .action((password, options) => {
    optionActions(options, 'ipc');
    delib.eth.createAccount(password)
      .then(address => {
        console.log(address);
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.error(err);
        delib.eth.closeIPC();
      });
  });

/** Unlocks an Ethereum account. */
program
  .command('unlock <index> <password> [time]')
  .description('Unlock an Ethereum account')
  .option('-c --ipchost [path]', 'Relative path to IPC host')
  .action((index, password, time, options) => {
    optionActions(options, 'ipc');
    time = time || 60 * 60 * 24;
    delib.eth.unlockAccount(index, password, time)
      .then(bool => {
        delib.eth.closeIPC();
      })
      .catch(err => {
        console.error(err);
        delib.eth.closeIPC();
      });
  });


/** Additional help */
program.on('--help', help);

program.parse(process.argv);

/** Catch invalid commands */
if (process.argv.length >= 3 && program._events[process.argv[2]] === undefined) {
  console.log('');
  console.log('  delib:  \'' + process.argv[2] + '\' is not a command. See \'delib --help\'.');
  console.log('');
}

/** Default output is help */
if (process.argv.length <= 2) {
  program.outputHelp();
}
